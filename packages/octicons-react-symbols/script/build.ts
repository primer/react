import fs from 'node:fs/promises'
import path from 'node:path'
import babel from '@babel/core'
import {generate} from '@babel/generator'
import {pascalCase} from 'change-case'
import {rolldown} from 'rolldown'
import data from '@primer/octicons/build/data.json' with {type: 'json'}

const {types: t} = babel
const SOURCE_DIRECTORY = path.resolve(import.meta.dirname, '../src')
const GENERATED_DIRECTORY = path.join(SOURCE_DIRECTORY, 'generated')

await fs.mkdir(GENERATED_DIRECTORY, {recursive: true})

// Symbol definitions
const icons = Object.values(data).map(icon => {
  const referenceName = `${pascalCase(icon.name)}Icon`
  const symbolName = `${pascalCase(icon.name)}Symbol`
  const definitions = Object.entries(icon.heights).map(([height, size]) => {
    const id = `symbol-octicon-${icon.name}-${height}`

    const jsx = t.jsxElement(
      t.jsxOpeningElement(t.jsxIdentifier('symbol'), [
        t.jsxAttribute(t.jsxIdentifier('id'), t.stringLiteral(id)),
        t.jsxAttribute(t.jsxIdentifier('viewBox'), t.stringLiteral(`0 0 ${size.width} ${height}`)),
      ]),
      t.jsxClosingElement(t.jsxIdentifier('symbol')),
      svgToJSX(size.ast),
    )
    return {
      id,
      height,
      width: size.width,
      jsx,
    }
    // const component = t.functionDeclaration(t.identifier(symbolName), [], t.blockStatement([t.returnStatement(jsx)]))
  })
  const definition = t.functionDeclaration(
    t.identifier(symbolName),
    [],
    t.blockStatement([
      t.returnStatement(
        definitions.length === 1
          ? definitions[0].jsx
          : t.jsxFragment(
              t.jsxOpeningFragment(),
              t.jsxClosingFragment(),
              definitions.map(def => def.jsx),
            ),
      ),
    ]),
  )

  const forwardRef = t.callExpression(t.identifier('forwardRef'), [
    t.functionExpression(
      t.identifier(referenceName),
      [t.identifier('props'), t.identifier('ref')],
      t.blockStatement([
        t.returnStatement(
          t.jsxElement(
            t.jsxOpeningElement(
              t.jsxIdentifier('Icon'),
              [
                t.jsxSpreadAttribute(t.identifier('props')),
                t.jsxAttribute(t.jsxIdentifier('ref'), t.jsxExpressionContainer(t.identifier('ref'))),
                t.jsxAttribute(
                  t.jsxIdentifier('sizes'),
                  t.jsxExpressionContainer(
                    t.objectExpression(
                      definitions.map(def =>
                        t.objectProperty(
                          t.stringLiteral(def.height),
                          t.objectExpression([
                            t.objectProperty(t.stringLiteral('width'), t.numericLiteral(def.width)),
                            t.objectProperty(t.stringLiteral('id'), t.stringLiteral(def.id)),
                          ]),
                        ),
                      ),
                    ),
                  ),
                ),
              ],
              true,
            ),
            t.jsxClosingElement(t.jsxIdentifier('Icon')),
            [],
          ),
        ),
      ]),
    ),
  ])

  forwardRef.typeParameters = t.tsTypeParameterInstantiation([
    t.tsTypeReference(t.identifier('SVGSVGElement')),
    t.tsTypeReference(t.identifier('OcticonReferenceProps')),
  ])

  const reference = t.variableDeclaration('const', [t.variableDeclarator(t.identifier(referenceName), forwardRef)])

  return {
    name: icon.name,
    definition: generate(definition).code,
    reference: generate(reference).code,
  }
})

function svgToJSX(node) {
  if (node.type === 'element') {
    const children = node.children.map(svgToJSX)

    if (node.name === 'svg') {
      if (children.length === 0) {
        throw new Error(`No children available for icon`)
      }

      return children.flat()
    }

    const attrs = Object.entries(node.attributes).map(([key, value]) => {
      if (typeof value !== 'string') {
        throw new Error(`Unknown value type: ${value}`)
      }
      return t.jsxAttribute(t.jsxIdentifier(key), t.stringLiteral(value))
    })
    const openingElement = t.jsxOpeningElement(t.jsxIdentifier(node.name), attrs, children.length === 0)
    const closingElement = t.jsxClosingElement(t.jsxIdentifier(node.name))

    if (children.length > 0) {
      return [t.jsxElement(openingElement, closingElement, children, false)]
    }

    return [t.jsxElement(openingElement, closingElement, [], true)]
  }

  throw new Error(`Unknown type: ${node.type}`)
}

let generated = ''

generated += `// This file is auto-generated by 'script/build.ts'. Do not edit directly.

import {forwardRef} from 'react'
import {Icon} from '../Icon'
import type {OcticonReferenceProps} from '../types'

`

for (const icon of icons) {
  generated += `//#region ${icon.name}\n`
  generated += `export ${icon.definition}\n`
  generated += `export ${icon.reference}\n`
  generated += '\n'
}

await fs.writeFile(path.join(GENERATED_DIRECTORY, 'icons.tsx'), generated)
